// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool using the template near this directory.
//     Please see this solution for more details: Codegen\Codegen.sln
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------
import { HttpClient } from '@angular/common/http';
import { Injectable } from '@angular/core';
import { Observable, of } from 'rxjs';
import { catchError, map, mergeMap } from 'rxjs/operators';
import {<%
dependencies.forEach((dependency, index) => { %>
	<%= dependency %><%= index + 1 !== dependencies.length ? ',' : '' %><%
}); %> } from '../models';

@Injectable({
	providedIn: 'root'
})
export class <%= name %>Service {
	public name = '<%= name %>';

	// TODO: Specify the proper dependencies for making HTTP calls.
	constructor(protected headerInfo:HeaderInfoService,
				protected http:HttpClient,
				protected serviceCache:ServiceCacheService,
				protected settings:SettingsService) {
	}
<% methods.forEach(method => { %>
	public <%= utils.translateReserved(utils.lowerCaseFirst(method.name)) %>(<%=
				utils.hasParams(method) ? 'args' + (utils.hasRequiredParams(method) ? '' : '?') + ':I' + utils.translateReserved(method.name) + 'Args' : ''
			%>)
		:Observable<%= method.returnType ? '<' + utils.parseType(method.returnType) + '>' : '<any>' %> {<%
	if (utils.hasParams(method) && !utils.hasRequiredParams(method)) { %>
		if (!args) {
			args = {};
		}<%
	} %><%=
		utils.protectPath(method) %>
		let url = this.settings.apiServer + `<%= utils.parsePath(method) %>`;<%=
		utils.outputQuery(method.parameters) %>
		let httpRequest = this.http
			.request<%= method.returnType && !utils.isString(method.returnType) ? '<' + utils.parseType(method.returnType) + '>' : '' %>('<%= utils.httpMethodToString(method) %>', url, {<%=
				utils.outputBody(method) %>
				headers: this.headerInfo.getApiHeaders('<%= utils.httpMethodToString(method) %>', this.settings.bearerToken),
				responseType: '<%= method.returnType === null || utils.isString(method.returnType) ? 'text' : 'json' %>'
			})
			.pipe(<% if (method.returnType) {%>
				map((json:any) => {<% if (utils.enableCaching(name, method.name)) { %>
					if (json) {
						this.serviceCache.store(url, json);
					}<% } %>
					if (json === null || json === undefined) {
						return null;
					}
					return <%= utils.fromJSON(method.returnType) %>;
				}),<% } %>
				catchError(err => this.handleError(err))
			);<%
		if (utils.enableCaching(name, method.name)) { %>
		return this.serviceCache
			.retrieve<%= method.returnType ? '<' + utils.parseType(method.returnType) + '>' : '<any>' %>(url)
			.pipe(
				mergeMap(json => json ? of(<%= utils.fromJSON(method.returnType) %>) : httpRequest)
			);<% } else { %>
		return httpRequest;<% } %>
	}
<% }); %>
}
<%
methods.filter(utils.hasParams).forEach(method => { %>

export interface I<%= utils.translateReserved(method.name) %>Args {<%= utils.parseParams(method.parameters) %>}<%
});
%>

export const enum <%= name %>Method {<%
methods.forEach(method => { %>
	<%= utils.translateReserved(utils.lowerCaseFirst(method.name)) %> = '<%= utils.translateReserved(utils.lowerCaseFirst(method.name)) %>',<%
}); %>
}
